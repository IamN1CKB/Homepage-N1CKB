<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pagine con css avanzato</title>
    <link rel="stylesheet" href="style2.css">
</head>
<body>
    <h1>Pagina per tip avanzate di css</h1>
    <p style="text-align: center;">
        In questa pagina mostrò delle tips per alcune chicche in CSS. vedi anche <a href="https://www.tiktok.com/@techlorem/video/7254927745900170501?is_from_webapp=1&sender_device=pc&web_id=7160711670368044550">qui</a>
    </p>
    <h2>
        Selector
    </h2>
    Per renderci i tag più selezionabili possiamo usare vari selector nelle CSS rule.
    <ul>
        <li>
            * { } per selezionare tutti gli elementi
        </li>
        <li>
            #id { } per selezionare l'elemento con l'id "id"
        </li>
        <li>
            .class { } per selezionare tutti gli elementi con la classe "class"
        </li>
        <li>
            .class1.class2 { } per selezionare tutti gli elementi che contengono entrambe le classi (ricorda di scriverli senza spazio tra di loro nella regola)
        </li>
        <li>
            tag { } per selezionare tutti gli elementi di un determinato tag
        </li>
        <li>
            tag.class { } per selezionare tutti i tag con una determinata classe 
        </li>
        <li>
            div p { } per selezionare tutti i tag p che sono discendenti (quindi anche figli diretti) del tag div selezionato. Facciamo un esempio.
            <textarea cols="90" rows="19">
                /*in CSS*/
                #div0 {
                    background-color: black;
                    width: fit-content;
                }
                #div0 p {
                    color: white;
                }

                <!--in HTML-->
                <div id="div0">
                    <p>Questo paragrafo è un figlio diretto del tag div con id="div0"</p>
                    <div>
                        <p>
                            Questo paragrafo è un discendente del tag div con id="div0"
                        </p>
                    </div>
                </div>
            </textarea>
            <div id="div0">
                <p>Questo paragrafo è un figlio diretto del tag div con id="div0"</p>
                <div>
                    <p>
                        Questo paragrafo è un discendente del tag div con id="div0"
                    </p>
                </div>
            </div>
        </li>
        <li>
            div > p { } per selezionare tutti i tag p che sono figli diretti del tag div selezionato (non basta essere discendenti). Facciamo un esempio.
            <textarea cols="100" rows="24">
                /*in CSS*/
                #div {
                    background-color: green;
                    width: fix-content;
                }
                #div > img {
                    border: 3px solid blue;
                    width: 300px;
                }

                <!--in HTML-->
                <div id="div">
                    <img src="media/nonna.JPG">
                    <img src="media/genny.JPG">
                    <p>
                        Questo è un paragrafo che non sarà influenzato dalla regola sopra
                    </p>
                    <div>
                        <div>
                            <img src="media/piobro.jpg">
                        </div>
                    </div>
                </div>
            </textarea>
            <div id="div">
                <img src="media/nonna.JPG">
                <img src="media/genny.JPG">
                <p>
                    Questo è un paragrafo che non sarà influenzato dalla regola sopra
                </p>
                <div>
                    <div>
                        <img src="media/piobro.jpg">
                    </div>
                </div>
            </div>
        </li>
        <li>
            div + p { } per selezionare tutti gli elementi "p" che sono immediatamente preceduti da un elemento "div".
            Questo selettore può essere utilizzato per applicare stili specifici solo agli elementi "p" che seguono
            direttamente un elemento "div". Facciamo un esempio.
            <textarea cols="50" rows="9">
                .div {
                    background-color: blue;
                    color: white;
                }
                .div + p {
                    border: 3px dashed black;
                }
            </textarea>
            <div class="div">
                tag div con classe div
            </div>
            <p>
                paragrafo immediatamente successivo a un elemento con classe div
            </p>
            <p>
                altro paragrafo non immediatamente successivo a un elemento con classe div
            </p>
            <div class="div">
                tag div con classe div
            </div>
            <p>
                altro paragrafo  immediatamente successivo a un elemento con class div
            </p>
            <div>
                <div class="div">
                    tag div con classe div all'interno di un tag div
                </div>
            </div>
            Si noti che il selettore div + p selezionerà solo i paragrafi direttamente successivi a un div.
            Paragrafi che non sono immediatamente preceduti da un div non saranno interessati da questo stile.
            Nonostante ciò tra i 2 tag si possono ignorare i commenti e i text node (testi scritti senza ulteriori tag)
        </li>
        <li>
            div ~ p { } per selezionare i paragrafi successivi di div, che sono anche fratelli di div (nello stesso livello dei tag)
            <textarea cols="50" rows="8">
                #div2 {
                    border: 1px solid;
                }
                #div2 ~ p {
                    color: brown;
                    border: 1px dashed white;
                }
            </textarea>
            <div>
                <p>
                    Questo paragrafo non sarà marrone perché non è successivo al tag div
                </p>
                <div id="div2">
                    Questo è il tag div con id "div2"
                </div>
                <p>
                    Questo è un paragrafo che sarà marrone perché è un fratello successivo a #div2
                </p>
                <span>
                    Questo è un tag span che non sarà marrone
                </span>
                <p>
                    Questo è un paragrafo che sarà marrone perché è un fratello successivo a #div2
                </p>
                <div>
                    <p>Questo è un paragrafo che non sarà marrone perché non è fratello di #div2, anche se è successivo ad esso</p>
                </div>
                <p>
                    Questo è un paragrafo che sarà marrone perché è un fratello successivo a #div2
                </p>
                <p>
                    Questo è un paragrafo che sarà marrone perché è un fratello successivo a #div2
                </p>
            </div>
        </li>
    </ul>
    <h3>
        Attribute Selector
    </h3>
    <p>
        Gli "attribute selector" (selettori di attributo) sono una parte avanzata dei selettori CSS che consentono
        di selezionare elementi HTML in base ai loro attributi e ai valori di tali attributi.
        Questi selettori consentono di applicare stili agli elementi che corrispondono a determinati attributi o valori degli attributi.
        Gli attribute selector sono una potente funzionalità che offre flessibilità nel targeting
        degli elementi in base alle loro proprietà.
    </p>
    <ul>
        Ci sono diversi tipi di attribute selector con una sintassi tra parentesi quadre:
        <li>
            selettore di attributo senza valore specifico=> tag[attributo] { }
            <textarea cols="100" rows="10">
                <!--in HTML-->
                <div class="div1" data-color="red">Questo paragrafo sarà rosso</div>
                <div class="div1" data-color="red">Questo paragrafo sarà rosso</div>
                <div class="div1" data-background="red">Questo paragrafo NON sarà rosso</div>

                /*in CSS*/
                .div1[data-color] {
                    color: red;
                }
            </textarea>
            <div class="div1" data-color="red">Questo paragrafo sarà rosso</div>
            <div class="div1" data-color="red">Questo paragrafo sarà rosso</div>
            <div class="div1" data-background="red">Questo paragrafo NON sarà rosso</div>
        </li>
        <li>
            selettore di attributo esatto=> tag[attributo="valore"] { }
            <textarea cols="100" rows="10">
                <!--in HTML-->
                <div class="div2" data-color="red">Questo paragrafo sarà rosso</div>
                <div class="div2" data-color="red">Questo paragrafo sarà rosso</div>
                <div class="div2" data-color="blue">Questo paragrafo sarà NON rosso</div>

                /*in CSS*/
                .div2[data-color="red"] {
                    color: red;
                }
            </textarea>
            <div class="div2" data-color="red">Questo paragrafo sarà rosso</div>
            <div class="div2" data-color="red">Questo paragrafo sarà rosso</div>
            <div class="div2" data-color="blue">Questo paragrafo sarà NON rosso</div>
        </li>
        <li>
            selettore di attributo contiene=> tag[attributo*="valore"] { }
            <br>
            Vuol dire che il valore dell'attributo contiene la parola indicata
            <textarea cols="100" rows="12">
                <!--in HTML-->
                <div class="foo-123">Questo sarà rosso</div>
                <div class="foo123">Questo sarà rosso</div>
                <div class="bar123foo">Questo sarà rosso</div>
                <div class="barfooo123">Questo sarà rosso</div>
                <div class="barfo0">Questo sarà NON rosso</div>

                /*in CSS*/
                div[class*="foo"] {
                    color: red;
                }
            </textarea>
            <div class="foo-123">Questo sarà rosso</div>
            <div class="foo123">Questo sarà rosso</div>
            <div class="bar123foo">Questo sarà rosso</div>
            <div class="barfooo123">Questo sarà rosso</div>
            <div class="barfo0">Questo sarà NON rosso</div>
        </li>
        <li>
            selettore di attributo separato da uno spazio=> tag[attributo~="valore"] { }
            <br>
            Seleziona gli elementi che hanno un attributo con un valore che include una parola specifica, separata da uno spazio.
            Per fare l'esempio userò un attributo personalizzabile.
            <textarea cols="50" rows="13">
                <!--in HTML-->
                <div data-boh="valore a caso">
                    Questo sarà rosso
                </div>
                <div data-boh="valore-a caso">
                    Questo NON sarà rosso
                </div>

                /*in CSS*/
                div[data-boh~="valore"] {
                    color: red;
                }
            </textarea>
            <div data-boh="valore a caso">
                Questo sarà rosso
            </div>
            <div data-boh="valore-a caso">
                Questo NON sarà rosso
            </div>
        </li>
        <li>
            selettore di attributo inizia con=> tag[attributo^="valore"] { }
            <br>
            <textarea cols="100" rows="10">
                <!--in HTML-->
                <a href="https://it.wikipedia.org/wiki/Pagina_principale">link per Wikipedia</a>
                <br>
                <a href="../../index.html">homepage</a>

                /*in CSS*/
                a[href^="https://"] {
                    color: cornflowerblue;
                }
            </textarea>
            <br>
            <a href="https://it.wikipedia.org/wiki/Pagina_principale">link per Wikipedia</a>
            <br>
            <a href="../../index.html">homepage</a>
            <p>
                In questo modo tutti i link che portano a domini di siti web esterni saranno colorati in modo diverso
            </p>
        </li>
        <li>
            selettore di attributo finisce con=> tag[attributo$="valore"] { }
            <br>
            <textarea cols="80" rows="10">
                <!--in HTML-->
                <div class="foobar-file">Questo sarà rosso</div>
                <div class="foobar-file">Questo sarà rosso</div>
                <div class="foobar-input">Questo NON sarà rosso</div>
                
                /*in CSS*/
                div[class$="file"] {
                    color: red;
                }
            </textarea>
            <div class="type-file">Questo sarà rosso</div>
            <div class="type-file">Questo sarà rosso</div>
            <div class="type-file-input">Questo NON sarà rosso</div>
        </li>
        <li>
            selettore di attributo in uno specifico prefisso=> tag[attributo|="valore"] { }
            <br>
            <textarea cols="80" rows="10">
                <!--in HTML-->
                <p lang="EN-us">Questo paragrafo sarà rosso</p>
                <p lang="EN-gb">Questo paragrafo sarà rosso</p>
                <p lang="PT-pt">Questo paragrafo NON sarà rosso</p>
                
                /*in CSS*/
                p[lang|="EN"] {
                    color: red;
                }
            </textarea>
            <p lang="EN-us">Questo paragrafo sarà rosso</p>
            <p lang="EN-gb">Questo paragrafo sarà rosso</p>
            <p lang="PT-pt">Questo paragrafo NON sarà rosso</p>
            <p>tra questo selettore (|=) e il selettore inizia con (^=) non c'è differenza ma per sintassi si usa questo con solo i prefissi</p>
        </li>
        <li>
            selettore di attributo => tag[attributo="valore" i] { }
            <br>
            In questo selettore c'è l'aggiunta di un modificatore di corrispondenza che viene aggiunto alla fine del selettore di attributo.
            Nel contesto dei selettori di attributo, i sta per "case-insensitive" (non sensibile alle maiuscole e minuscole).
            Questo significa che la corrispondenza dell'attributo e del valore non terrà conto delle differenze tra maiuscole e minuscole.
            <textarea cols="80" rows="10">
                <!--in HTML-->
                <div lang="EN">Questo sarà rosso</div>
                <div lang="en">Questo sarà rosso</div>
                <div lang="PT">Questo NON sarà rosso</div>

                /*in CSS*/
                div[lang="EN" i] {
                    color: red;
                }
            </textarea>
            <div lang="EN">Questo sarà rosso</div>
            <div lang="en">Questo sarà rosso</div>
            <div lang="PT">Questo NON sarà rosso</div>
        </li>
    </ul>
    
    <h2>
        Le pseudo class 
    </h2>
    <p>
        In CSS, le pseudo-classi sono utilizzate per selezionare e modificare lo stile di elementi HTML in base a determinati stati o interazioni.
        <br>
        Esse hanno una sintassi che si aggiunge successivamente al selettore della regola CSS
        <br>
        selettore:pseudo-class {
            <br>
            proprietà: valore;
            <br>
        }
    </p>
    <p>
        Le pseudo-classi in CSS possono avere uno o due punti (:) come prefisso, e la differenza tra i due dipende dal contesto
        in cui vengono utilizzati.
    </p>
    <ul>
        <li>
            Pseudo-classe con un solo : (es. :hover, :active, :nth-child(2)):
            <br>
            Le pseudo-classi con un solo : sono le più comuni e vengono utilizzate per selezionare e stiliare elementi in base a stati
            o caratteristiche specifiche.
            Ad esempio, :hover viene utilizzata per applicare uno stile quando si posiziona il cursore sopra un elemento, mentre
            :active viene utilizzata per applicare uno stile quando un elemento è attivo, ad esempio quando un pulsante viene premuto.
        </li>
        <li>
            Pseudo-classe con due :: (es. ::before, ::after, ::first-line):
            <br>
            Le pseudo-classi con due :: sono chiamate pseudo-elementi. Questi vengono utilizzati per selezionare e stiliare parti
            specifiche di un elemento che non sono rappresentate direttamente nel file HTML.
            Ad esempio, ::before e ::after vengono utilizzate per inserire contenuto aggiuntivo prima o dopo un elemento
            (ad esempio, per aggiungere icone o decorazioni). ::first-line viene utilizzata per selezionare la prima riga di
            testo all'interno di un elemento.
        </li>
    </ul>
    <p>
        Ecco alcuni esempi di come vengono utilizzate le pseudo-classi e i pseudo-elementi
    </p>
    <textarea  cols="100" rows="14">
        /* Pseudo-classe con un solo : */
        a:hover {
          color: blue; /* Cambia il colore del testo quando si posiziona il cursore sopra un link */
        }

        /* Pseudo-elemento con due :: */
        #p::before {
          content: "► "; /* Aggiunge una freccia prima di ogni paragrafo */
        }

        #p::first-line {
          font-weight: bold; /* Rende grassetto la prima riga di ogni paragrafo */
        }
    </textarea>
    <br>
    <a href="">prova a mettere il cursore sopra al link</a>
    <p id="p">
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
    </p>
    <h3>
        Child pseudo class
    </h3>
    <p>
        I child pseudo class vengono usate per selezionare elementi figli specifici all'interno di un elemento genitore.
        Queste pseudo-classi consentono di applicare stili agli elementi figli in base alla loro posizione o relazione all'interno dell'albero HTML.
        <br>
        Praticamente, seleziona tutti i tag che sono figli specifici di qualche altro tag nell'albero HTML. Ad esempio div:first-child seleziona tutti i tag div che sono primi figli di un tag genitore.
    </p>
    <p>
        Vediamo come funziona la sintassi di queste pseudo-class (uso sempre la classe prova in modo da caratterizzare solo questi elementi):
    </p>
    <textarea cols="70" rows="22">
        /*in CSS*/
        .prova:first-child {
            background-color: red;
            width: fit-content;
        }

        <!--in HTML-->
        <div class="prova">
            <div class="prova">
                primo figlio
            </div>
            <div class="prova">
                secondo figlio
                <div class="prova">
                    primo figlio del secondo figlio
                </div>
                <div class="prova">
                    secondo figlio del secondo figlio
                </div>
            </div>
        </div>
    </textarea>
    <div class="prova">
        <div class="prova">
            primo figlio
        </div>
        <div class="prova">
            secondo figlio
            <div class="prova">
                primo figlio del secondo figlio
            </div>
            <div class="prova">
                secondo figlio del secondo figlio
            </div>
        </div>
        <div class="prova">
            terzo figlio
        </div>
    </div>
    <p>
        Per rendere queste pseudo class più specifiche ancora, di solito si usano in combinazione con il selettore discendenza o il selettore figlio diretto. Ad esempio: 
    </p>
    <textarea cols="100" rows="8">
        div p:first-child {
            /*styling*/
        } /*Questo seleziona tutti i paragrafi p che sono primi figli e discendenti di tag div*/

        div > p:first-child {
            /*styling*/
        } /*Questo seleziona tutti i paragrafi p che sono primi figli diretti di tag div*/
    </textarea>
    <p>
        Ora vediamo come si usano i diversi tipi di queste pseudo-class.
        Per capire come si usano creo un tag div con vari tag numerati dopo la seguente lista in cui ci sono differenti stili
    </p>
    <textarea cols="50" rows="32">
        /*in CSS*/
        #container-child-pseudo-class {
            display: flex;
            gap: 30px;
            border: 2px red solid;
            width: fit-content;
            padding: 5px;
        }
        <!--in HTML-->
        <div id="container-child-pseudo-class">
            <div>1(div)</div>
            <div>2(div)</div>
            <div>3(div)</div>
            <div>4(div)</div>
            <div>5(div)</div>
            <div>6(div)</div>
            <span>7(span)</span>
            <div>8(div)</div>
            <div>9(div)</div>
            <div>10(div)</div>
            <div>11(div)</div>
            <div>12(div)</div>
            <div>13(div)</div>
            <div>14(div)</div>
            <div>15(span)</div>
            <div>16(div)</div>
            <div>17(div)</div>
            <div>18(div)</div>
            <div>19(div)</div>
            <div>20(div)</div>
        </div>
    </textarea>
    <div id="container-child-pseudo-class">
        <div>1(div)</div>
        <div>2(div)</div>
        <div>3(div)</div>
        <div>4(div)</div>
        <div>5(div)</div>
        <div>6(div)</div>
        <span>7(span)</span>
        <div>8(div)</div>
        <div>9(div)</div>
        <div>10(div)</div>
        <div>11(div)</div>
        <div>12(div)</div>
        <div>13(div)</div>
        <div>14(div)</div>
        <div>15(span)</div>
        <div>16(div)</div>
        <div>17(div)</div>
        <div>18(div)</div>
        <div>19(div)</div>
        <div>20(div)</div>
    </div>
    <ul>
        <li>
            <i>:first-child</i> per selezionare il primo figlio
            <textarea cols="70" rows="7">
                #container-child-pseudo-class > div:first-child {
                    color: red;
                }
                #container-child-pseudo-class > span:first-child {
                    color: red;
                }
            </textarea>
            Nel secondo caso la regola non funziona perché il primo figlio non è un tag span 
        </li>
        <li>
            <i>:nth-child(3)</i> per selezionare il terzo elemento
            <textarea cols="70" rows="5">
                /*stavolta non specifichiamo il tag div per comodità*/
                #container-child-pseudo-class > :nth-child(3) {
                    color: blue;
                }
            </textarea>
        </li>
        <li>
            <i>:nth-child(n+3)</i> per selezionare tutti i figli dal terzo elemento in poi (tipo come in matematica con la periodicità => n appartenente a N)
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-child(n+3) {
                    font-weight: bold;
                }
            </textarea>
        </li>
        <li>
            <i>:nth-child(3n)</i> per selezionare tutti i figli in ordine multipli di tre
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-child(3n) {
                    border: 1px solid black;
                }
            </textarea>
        </li>
        <li>
            <i>:nth-child(3n+1)</i> per selezionare tutti i figli in ordine multipli di 3 + 1
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-child(3n+1) {
                    color:chartreuse;
                }
            </textarea>
        </li>
        <li>
            <i>:nth-child(-n+3)</i> successione da capire con la matematica sostituendo n a ogni numero naturale: -0+3=3; -1+3=2; -2+3=1; -3+3=0; -4+3=-1; 
            <br>
            A questo punto è inutile continuare perché lo 0 e i numeri negativi non possono essere ordine di figli. In questo modo abbiamo selezionato i primi 3 elementi.
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-child(-n+3) {
                    transform: rotate(180deg);
                }
            </textarea>
        </li>
        <li>
            <i>:nth-child(odd)</i> per selezionare gli elementi in ordine dispari
            <br>
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-child(odd) {
                    text-decoration: underline;
                }
            </textarea>
        </li>
        <li>
            <i>:nth-child(even)</i> per selezionare gli elementi in ordine pari
            <br>
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-child(even) {
                    text-decoration: overline;
                }
            </textarea>
        </li>
        <li>
            <i>:last-child</i> per selezionare l'ultimo elemento
            <br>
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :last-child {
                    color: brown;
                }
            </textarea>
        </li>
        <li>
            <i>:nth-last-child(3)</i> per selezionare il terzultimo elemento
            <br>
            <textarea cols="70" rows="4">
                #container-child-pseudo-class > :nth-last-child(3) {
                    color: yellowgreen;
                }
            </textarea>
        </li>
    </ul>




    <br>
    <ul>
        <li>
            :active=>  viene applicato ad ogni elemento che viene attivato o cliccato (solo nel momento del click), come ad esempio un link o un bottone che viene cliccato
            <br>
            <a href="">quando clicchi diventa bianco</a>
            <br>
            <button>quando clicchi il background-color diventa bianco</button>
            <br>
            <p id="paragrafo_da_attivare">
                paragrafo che diventa rosso mentre clicchi
            </p>
            <!-- Come si può notare, lo stile torna subito come prima poco dopo.
            Un trucchetto per usare questa pseudo class anche con paragrafi e altro è attivarli tramite un link che riporta a loro.
            <a href="#paragrafo_da_attivare">link che porta al paragrafo sopra</a> -->
        </li>
        <li>
            :any
        </li>
      
        <li>
            :
        </li>
        <li>
            :
        </li>
        <li>
            :
        </li>
        <li>
            :
        </li>
        <li>
            :
        </li>
        <li>
            :
        </li>
        <li>
            :
        </li>
        <li>
            :
        </li>
    </ul>





    <h3>
        ::placeholder pseudo class
    </h3>
    <p>
        Questo selettore se aggiunto a un file input dotato di placeholder, consente di modificare lo stile del placeholder.
        Facciamo un esempio.
        <br>
        Ricorda che si scrive con :: e non con solo :
    </p>
    <textarea cols="40" rows="4">
        #input::placeholder {
            color: red;
        }
    </textarea>
    <br>
    <input type="text" placeholder="scrivi qui" id="input">



    <h3>
        :placeholder-shown pseudo class
    </h3>
    <p>
        questo selettore, usato su un tag input o textarea, consente di modificare l'aspetto del tag solo quando è visibile il placeholder
        ossia quando non è stato scritto nulla all'interno del tag. Facciamo un esempio:
        <br>
        Ricorda che si scrive con : e non ::
    </p>
    <textarea cols="120" rows="14">
        #form1{
            border: solid green;
            width: min-content;
        }
        #input1 {
            width: 200px;
            height: 35px;
            /*questa è la grandezza del tag input quando è scritto qualcosa dentro*/
        }
        #input1:placeholder-shown {
            height: auto;
            /*questa è la grandezza del tag input quando non è scritto nulla dentro (con placeholder visibile)*/
        }
    </textarea>
    <form id="form1">
        <label for="input1">tag label</label>
        <input type="text" placeholder="se scrivi aumenta l'altezza" id="input1">
    </form>



    <h3>
        :has() pseudo class
    </h3>
    <p>
        L'idea di base della pseudo-classe :has è di selezionare un elemento genitore in base al fatto che contenga determinati elementi figli che soddisfano un selettore specifico. Ad esempio, potresti voler selezionare tutti i paragrafi che contengono link all'interno di un articolo.

        Ecco un esempio di come la pseudo-classe :has potrebbe funzionare 
    </p>
    <p>
        In questo esempio, tutti i paragrafi con classe "p" che contengono link al loro interno verrebbero stilizzati con uno sfondo giallo.
    </p>
    <textarea cols="50" rows="4">
        .p:has(a) {
            background-color: yellow;
        }
    </textarea>
    <p class="p">
        questo è un paragrafo con classe "p" senza link
    </p>
    <p class="p">
        questo è un paragrafo con classe "p" con il <a href="">link</a>
    </p>

    <p>
        la pseudo class :has() si può combinare con altre pseudo class e selector
    </p>
    <textarea cols="100" rows="12">
        #label:has(~ input:placeholder-shown) {
            border: dashed brown;
            /*in questo modo facciamo si che il label sia a trattini solo se ha
            come fratello successivo (operatore ~) un tag input con il placeholder mostrato*/
        }
        #label {
            border: solid brown;
        }
        #label ~ input {
            width: 300px;
        }
    </textarea>
    <form>
        <label for="input2" id="label">Label dell'input</label>
        <br>
        <input type="text" id="input2" placeholder="se scrivi qualcosa il label cambia bordi">
    </form>


    <h3>
        :invalid pseudo class
    </h3>
    <p>
        La pseudo-classe :invalid viene utilizzata per selezionare gli elementi di un modulo (come campi di input,
        caselle di selezione o aree di testo) che hanno errori di validazione nei dati inseriti dall'utente.
        Ecco come funziona:
    </p>
    <ul>
        <li>
            Validazione: HTML5 ha introdotto attributi ed elementi incorporati per la validazione dei moduli,
            come required (obbligatorio), min (valore minimo), max (valore massimo), pattern (schema di validazione), ecc.
            Questi attributi definiscono le regole per la validazione dei dati inseriti dall'utente.
        </li>
        <li>
            Input dell'utente: Quando un utente interagisce con un elemento del modulo, ad esempio scrivendo in un
            campo di input, il browser verifica l'input rispetto alle regole di validazione definite.
        </li>
        <li>
            Pseudo-classe :invalid: Se l'input dell'utente non rispetta le regole di validazione,
            il browser segnala che l'elemento del modulo è "non valido". A questo punto, è possibile utilizzare
            la pseudo-classe :invalid per applicare stili CSS specifici all'elemento con input non valido.
        </li>
    </ul>
    <p>
        Ad esempio, supponiamo di avere un campo di input che dovrebbe accettare un indirizzo email valido:
    </p>
    <br>
    <textarea cols="120" rows="12">
        /*in CSS*/
        .input {
            width: 300px;
        }
        .input:invalid {
            border: 2px solid red;
        }

        <!--in HTML-->
        <input type="email" class="input" placeholder="inserisci l'email" required>
    </textarea>

    <form action="">
        <input type="email" class="input" placeholder="Inserisci l'email" required>
        <input type="number" class="input" placeholder="inserisci età" min="5" max="17">
        <br>
        <button type="submit">Iscriviti</button>
    </form>
    <p>
        <ul>
            In questo modo in diversi casi il bordo dei tag input diventa rosso:
            <li>
                quando non è stato inserito nulla nei tag input con l'attributo required
            </li>
            <li>
                quando non si rispetta la sintassi per il tag con type="email"
            </li>
            <li>
                quando si inserisce un valore non compreso tra il massimo e il minimo stabilito dagli attributi min e max
            </li>

        </ul>
    </p>


    <h2></h2>
    <h3>
        come nascondere una parte di un testo
    </h3>
    vedi 
    <a href="https://www.tiktok.com/@iamdillion/video/7257198565880122629?is_from_webapp=1&sender_device=pc&web_id=7160711670368044550">
        qui
    </a> e poi
    <a href="https://www.tiktok.com/@iamdillion/video/7258321932800527621?is_from_webapp=1&sender_device=pc&web_id=7160711670368044550">
        qui
    </a>
    <p>
        per troncare un paragrafo in una riga o in righe multiple dobbiamo usare varie proprietà CSS.
        <br>
        nel caso di una sola linea possiamo usare le varie proprietà
    </p>
    <textarea cols="80" rows="15">
        #box {
            width: 400px;
            border: solid 2px;
            padding: 10px;
        }
        #p1 {
            white-space: nowrap;
            /* questo dispone tutto su una linea rompendo il container */
            overflow: hidden;
            /* questo nasconde la parte di testo fuori dal container */
            text-overflow: ellipsis;
            /* questo mette i puntini sospensivi poco prima dell'overflow */
        }
    </textarea>
    <div class="box">
        <p id="p1">
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
        </p>
    </div>
    <p>
        Invece nel caso di un troncamento a più righe, dobbiamo usare proprietà diverse.
    </p>
    <div class="box">
        <p id="p2">
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
        </p>
    </div>


    <h2>
        Prefissi di vendor (da rivedere)
    </h2>
    <br>
    Le proprietà CSS con il trattino `-` all'inizio sono chiamate "prefissi di vendor" o "prefissi del fornitore". Queste proprietà vengono utilizzate per applicare stili specifici a determinati browser o motori di rendering che potrebbero richiedere implementazioni sperimentali o proprietarie. I prefissi di vendor sono spesso usati per introdurre nuove funzionalità CSS che potrebbero non essere ancora pienamente supportate da tutti i browser.

    Un esempio comune di prefisso di vendor è `-webkit-`, che è utilizzato principalmente per proprietà specifiche di WebKit, il motore di rendering utilizzato da browser come Safari e alcuni altri. Altri esempi di prefissi di vendor includono `-moz-` per Mozilla Firefox e `-ms-` per Microsoft Internet Explorer o Microsoft Edge (versioni precedenti).
    
    Ad esempio, per utilizzare l'animazione CSS con il prefisso `-webkit-` per il supporto di WebKit (come Safari), potresti scrivere:
    
    ```css
    @-webkit-keyframes animazione {
      /* Definizione dell'animazione qui */
    }
    ```
    
    Tuttavia, è importante notare che l'uso eccessivo di prefissi di vendor può portare a un codice CSS gonfio e difficile da mantenere. Con il passare del tempo, molti nuovi standard CSS sono diventati più stabili e ampiamente supportati, riducendo la necessità di utilizzare prefissi di vendor per molte funzionalità. Invece di utilizzare prefissi, è spesso consigliabile utilizzare funzionalità CSS che hanno un buon supporto trasversale tra i browser.
    
    Gli sviluppatori spesso utilizzano strumenti come autoprefixer, che è una libreria o un plugin per vari strumenti di sviluppo (ad esempio, PostCSS) che aggiunge automaticamente i prefissi di vendor solo dove necessario in base ai dati sul supporto del browser. Questo semplifica notevolmente la gestione dei prefissi di vendor e aiuta a mantenere il codice CSS più pulito e mantenibile.
    I prefissi di vendor più importanti sono quelli utilizzati per supportare funzionalità specifiche in diversi browser o motori di rendering. Tuttavia, è importante notare che l'uso dei prefissi di vendor è diventato meno comune grazie alla diffusione di nuove specifiche CSS che sono state stabilizzate e implementate in modo più uniforme nei browser moderni. Ecco alcuni dei prefissi di vendor più noti:
    
    1. **-webkit-**: Utilizzato per il supporto del motore di rendering WebKit, che è alla base di browser come Safari e alcuni altri browser meno noti. Ad esempio, `-webkit-transform` per trasformazioni CSS.
    
    2. **-moz-**: Utilizzato per il supporto di Mozilla Firefox. Ad esempio, `-moz-border-radius` per bordi arrotondati.
    
    3. **-ms-**: Utilizzato per il supporto di Internet Explorer e Microsoft Edge (versioni precedenti). Ad esempio, `-ms-flexbox` per il modello di layout Flexbox.
    
    4. **-o-**: Utilizzato per il supporto di Opera, anche se è diventato meno rilevante dato che Opera ora utilizza il motore di rendering Blink, simile a WebKit. Ad esempio, `-o-transition` per transizioni CSS.
    
    È importante notare che, quando si utilizzano i prefissi di vendor, dovresti sempre includere anche la versione non prefissata della proprietà CSS, poiché alcuni browser potrebbero supportare sia la versione non prefissata che quella prefissata. Ad esempio, puoi scrivere:
    
    ```css
    div {
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
      border-radius: 5px;
    }
    ```
    
    Tuttavia, come menzionato in precedenza, con l'avanzare degli standard CSS e il miglioramento del supporto dei browser, l'uso dei prefissi di vendor è diventato meno necessario per molte funzionalità. È sempre una buona pratica verificare il supporto dei browser per le funzionalità che intendi utilizzare e, se possibile, utilizzare le versioni non prefissate delle proprietà CSS.



    <br><br><br><br>
    <footer>
        Per la lezione precedente vedi <a href="index-esercizio.html">qui</a>
        <br>
        Per la homepage <a href="../../index.html">qui</a>
    </footer>
</body>
</html>